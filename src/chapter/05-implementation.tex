% !TEX root = ../report.tex

\chapter{Implementation}

\minitoc

This chapter discusses the major requirements, and implementation of the different algorithms and datastructures in the system. And is meant for the reader to get insight into what was actually implemented.

TODO: Something about each section after done
\clearpage

\section{Major Requirements}\label{impl:Major Requirements}
\subsection{FR1}
\begin{quotation}
\em The system must be able to harvest tweets and/or users from Twitter that are related to a movie in the Netflix-dataset %not to edit, unless edit for all
\end{quotation}

The fields Scrape and REST are implemented. Scrape can harvest tweets and users related to a movie title. REST can retrieve users related to users that relate to tweets about movies. Stream is implemented in a side project for quick iteration and hands-on testing. It can retrieve tweets related to movie titles.

The harvesters implemented are
\begin{itemize}
\item NetflixMovieTweetScrape
\item TwitterUserFolloweeREST
\end{itemize}

NetflixMovieTweetScrape iterates through all netflix movies and uses the field Scrape to harvest tweets related to each netflix movie. TwitterUserFolloweeREST iterates over all twitter users in storage and uses the field REST to harvest followees for this user.

Thus, the system can harvest tweets and users from Twitter related to movies in the netflix dataset and the requirement is therefore implemented.

\subsection{FR6}
\begin{quotation}
\em The system must be able to supplement Netflix-dataset with tweets and/or users from Twitter that are related to a movie in the Netflix-dataset %not to edit, unless edit for all
\end{quotation}

Because a dataset could not be retrieved from Twitter due to time constraints on the API based fields and legal constraints on the Scrape field there was no complete set of twitter data points to build a dataset with. The dataset building algorithm was not implemented. Thus, this requirement was not implemented, but remains a task for further work.

\subsection{FR7}\label{subsec:FR7}
\begin{quotation}
\em The system must be able to predict ratings of the movies for all users in any dataset that reflects the Netflix dataset %not to edit, unless edit for all
\end{quotation}

Since the data from twitter is not gathered and combined with the Netflix-data this requirement is not implemented, but rather a task for further work.

\subsection{NFR1}
\begin{quotation}
\em The system must be able to cost efficiently predict a rating of a movie for a given user %not to edit, unless edit for all
\end{quotation}

This requirement is not implemented, but taken into account when prediction algorithm was chosen. This is as \ref{subsec:FR7}, a task for further work and research.


\section{Data structures}\label{impl:Data structures}
\subsection{NoSQL Database Mapping}
In order to achieve synchronization with mongoDB, the datamapper MongoMapper is used. MongoMapper ensures that an database record that is associated with an object is automatically updated when one of the objects attributes are changed. In the case of Twilm, these are all classes in the module Models.

The attributes are referred to as keys in MongoMapper. Instead of declaring variables in a regular ruby fashion, mongomapper keys are declared. An example of a key used in the implementation for a TwitterUser is "key name".

MongoMappers relationship descriptors are also utilized. When an object is pointing to many instances of another object, the descriptor many can be used instead of declaring a regular variable. When an object is pointing to one instance of another object, the keyword one is used. An example used in the implementation for TwitterUser is "many twitter\_tweets" and conversely, "one twitter\_user" in TwitterTweet.

Validations in mongomapper are used to ensure that certain keys and relationships are not stored with nil values. In the implementation, validations are used wherever there is a key that should always be stored. An example is "validates\_presence\_of text" in TwitterTweet.


\subsection{Data structure: Netflix}

\subsubsection{User}
The NetflixUser datastructure models the users in the netflix prize dataset. The implementation reflects the netflix movies the user has rated and also holds a cached average of these ratings. The implementation can be seen in figure~\ref{figure:datastructure-netflix-user}.

	\begin{figure}[H]
	\includegraphics[width=4in]{image/datastructure-netflix-user.png}
	\centering
	\caption{The implemented datastructure of a NetflixUser. Curly brackets denote a hash. Square brackets denote a list of items of a certain type. Text encapsulated in smaller than bigger than denotes keys in the object it is declared in or other objects. Black keys are required, while grey keys are not required.}
	\label{figure:datastructure-netflix-user}
	\end{figure}

\subsubsection{Movie}
The NetflixUser datastructure models the movies in the netflix prize dataset. The implementation have the keys title and year which reflects the title of the movie and the year it was released. It also reflects the netflix users that have rated the movie and the rating itself. The implementation can be seen in figure~\ref{figure:datastructure-netflix-movie}.

	\begin{figure}[H]
	\includegraphics[width=4in]{image/datastructure-netflix-movie.png}
	\centering
	\caption{The implemented datastructure of a NetflixMovie. Curly brackets denote a hash. Square brackets denote a list of items of a certain type. Text encapsulated in smaller than bigger than denotes keys in the object it is declared in or other objects. Black keys are required, while grey keys are not required.}
	\label{figure:datastructure-netflix-movie}
	\end{figure}

\subsection{Data structure: Twitter}

\subsubsection{User}
The TwitterUser datastructure models users harvested from Twitter. The implementation have the key name which reflects the users nickname on Twitter. It also reflects the optional many relationship to TwitterTweets which referes to a collection of Tweets posted by the user. The TwitterUser's relationship to other TwitterUsers are reflected in the optional many relationships followees and followers. The key related\_to\_netflix\_movie refers to which NetflixMovie the user was harvested and is a twitter data point for. The implementation can be seen in figure~\ref{figure:datastructure-twitter-user}.

	\begin{figure}[H]
	\includegraphics[width=4in]{image/datastructure-twitter-user.png}
	\centering
	\caption{The implemented datastructure of a TwitterUser. Curly brackets denote a hash. Square brackets denote a list of items of a certain type. Text encapsulated in smaller than bigger than denotes keys in the object it is declared in or other objects. Black keys are required, while grey keys are not required.}
	\label{figure:datastructure-twitter-user}
	\end{figure}

\subsubsection{Tweet}
The TwitterUser datastructure models tweets harvested from Twitter. The implementation have the key text which reflects the text content of the Tweet, and the key by\_twitter\_user which reflects which user posted the tweet. The key related\_to\_netflix\_movie refers to which NetflixMovie the user was harvested and is a twitter data point for. The implementation can be seen in figure~\ref{figure:datastructure-twitter-user}.

	\begin{figure}[H]
	\includegraphics[width=4in]{image/datastructure-twitter-tweet.png}
	\centering
	\caption{The implemented datastructure of a TwitterTweet. Curly brackets denote a hash. Square brackets denote a list of items of a certain type. Text encapsulated in smaller than bigger than denotes keys in the object it is declared in or other objects. Black keys are required, while grey keys are not required.}
	\label{figure:datastructure-twitter-user}
	\end{figure}

\subsection{Data structure: Dataset}
This datastructure is not implemented due to the fact that it is only needed by the dataset building algorithm in section~\ref{algorithm-design:dataset-building} which is not implemented.
\subsection{Data structure: Prediction}
This datastructure is not implemented due to the fact that it is only needed by the prediction algorithm in section~\ref{algorithm-design:prediction} which is not implemented.

\section{Functional Modules}\label{impl:Functional Modules}

\subsection{Fields}
\subsubsection{Scrape}
Implemented
uses gem anemone
\subsubsection{Stream}
Implemented separately.
uses gem tweetstream
\subsubsection{Search}
Inferior to stream section \ref{sec:prestrud-eval-twitter}
\subsubsection{REST}
Implemented
uses gem twitter
\subsection{Harvesters}
NetflixMovieTweetScrape
TwitterUserFolloweeREST
\subsubsection{NetflixMovieTweetScrape}
\subsubsection{TwitterUserFolloweeREST}

\section{Testing}\label{impl:Testing}
Også diskuter hvordan du har tenkt å utføre testen din (validering og evaluering).

Testing of the RMSE score of the system is not tested since the needed data was not acquired from twitter~\ref{sec:twitter}, neither is the merging of the Netflix-dataset with the Twitter-data for the same reason.
